---
title: "Preliminary investigation of the carbamylation profile in proteins excreted in 24-hour urine after injection of Bothrops jararaca venom in a murine model"
author: "Pedro Galdiano de Castro"
execute:
  echo: false
  warning: false
  message: false
format: html
code-fold: true
editor_options:
  chunk_output_type: console
---

## ABSTRACT


# Load packages dependencies
```{r}
library(diann) # to extract the MaxLFQ matrix from DIANN report
library(arrow) # to read the report.parquet file
library(here) # to avoid the need for use the path while loading the data
library(tidyverse) # to do the data wrangling, plots, etc...
library(janitor) # to clean the column names
library(ggpointdensity) # to reconstruct the m/z density map
library(naniar) # for sparsity analysis
library(factoextra) # to plot the PCA
library(patchwork) # to combine plots
library(lsa) # to calculate the cosine similarity
library(ggvenn) # to plot the Venn diagram
library(paletteer) # to use the nice color palette
library(ggtext) # to provide Markdown and HTML formatting in ggplot2
library(ggrepel) # to avoid the overlapping of the labels in the plots
library(kableExtra) # to format the tables
library(limma) # to calculate the differential abundance
library(DIAgui) # to extract iBAQ values

cat("\n\nAll packages were activated.\n")
```

# Global variables
```{r}
# This map should be ordered by the sample-name (code = sample_name), this will
# define the order everything will be ploted
#
# A amostra precisa terminar com espaço, letra r , número (" r1", " r2", " r637")
# Sim, é uma gambiarra. E funciona!
labels <- c(
  P2_01 = "NaCl_r1",
  P2_02 = "NaCl_r2",
  P2_03 = "NaCl_r3",
  P2_04 = "Actinonin_15mg_r1",
  P2_05 = "Actinonin_15mg_r2",
  P2_06 = "Actinonin_15mg_r3",
  P1_04 = "Actinonin_30mg_r1",
  P1_05 = "Actinonin_30mg_r2",
  P2_11 = "JPMOEt_50mg_r1",
  P2_12 = "JPMOEt_50mg_r2",
  P1_10 = "JPMOEt_100mg_r1",
  P1_11 = "JPMOEt_100mg_r2",
  P1_12 = "JPMOEt_100mg_r3",
  P1_02 = "Venom_r1",
  P1_03 = "Venom_r2",
  P2_07 = "Ven_Actn_15mg_r1",
  P2_08 = "Ven_Actn_15mg_r2",
  P2_09 = "Ven_Actn_15mg_r3",
  P1_07 = "Ven_Actn_30mg_r1",
  P1_08 = "Ven_Actn_30mg_r2",
  P1_09 = "Ven_Actn_30mg_r3",
  P2_13 = "Ven_jPMOEt_50mg_r1",
  P2_14 = "Ven_jPMOEt_50mg_r2",
  P2_15 = "Ven_jPMOEt_50mg_r3",
  P1_13 = "Ven_jPMOEt_100mg_r1",
  P1_14 = "Ven_jPMOEt_100mg_r2",
  P1_15 = "Ven_jPMOEt_100mg_r3"
)

# Params to filter by
params <- list(pgScore = 0.75,
  eqScore = 0.75,
  threshold = 0.3,
  samplesToRemove = c("NaCl_r1"),
  numberOfClusters = 4)

colors <- c(
  "#FED789FF", "#023743FF", "#72874EFF", "#476F84FF", "#A4BED5FF",
  "#453947FF", "#66C2A5", "#FC8D62", "#FFD92F", "#8DA0CB"
)




cat("\n\nGlobal variables were loaded.\n")
```

# Helper functions ----
```{r}
# Return a dataset with the coefficients of variation
CV_Matrix <- function(data, condition, gambiarra) {
  # data <- CreateImputationMatrix()
  # condition <- "Ven + Actn 30 mg"
  # gambiarra <- paste0("^",str_replace(condition, "\\+", "\\\\+")," r[0-9]+")
  #
  selected <- dplyr::select(
    data,
    protein,
    str_subset(colnames(data), gambiarra)
  )

  selected_rowwise <- rowwise(selected)

  mutated <- dplyr::mutate(selected_rowwise,
    across(where(is.numeric), ~ 2^(.) - 1),
    cv = 100 *
      (
        sd(c_across(where(is.numeric)), na.rm = TRUE) /
          mean(c_across(where(is.numeric)), na.rm = TRUE)
      ),
    condition = condition
  )
  return(dplyr::select(mutated, protein, cv, condition))
}

# Generate the diannReport.rds from report.parquet file
DiannReport <- function(runs, directory = "../data/DIANN_results/") {

  report <- arrow::read_parquet(paste(directory, "report.parquet", sep = ""))

  reportFiltered <- dplyr::filter(
    report,
    Lib.PG.Q.Value <= 0.01 &
      Lib.Q.Value <= 0.01 &
      PG.Q.Value <= 0.01
  )

  reportRecoded <- dplyr::mutate(reportFiltered,
    Run = recode(Run, !!!runs),
    Run = factor(Run, levels = unname(runs)),
    condition = str_remove(Run, "_r1|_r2|_r3"),
    File.Name = Run,
    peptide_length = nchar(Stripped.Sequence)
  )

  diannReport <- dplyr::filter(
    reportRecoded,
    str_detect(Protein.Names, "MOUSE")
  )

  cat("\ndiannReport were loaded.")

  return(diannReport)
}

# TODO: I am not sure if this actually changes something...
# Adjust the general theme for the plots :
theme_update(
  text = element_text(color = "black", size = 20),
  axis.text = element_text(color = "black"),
  axis.title = element_text(color = "black", face = "bold"),
  strip.background = element_blank(),
  strip.text = element_text(face = "bold"),
  legend.title = element_text(face = "bold", hjust = 0.5),
  legend.title.position = "top"
)


FilterByScore <- function(data) {

  result <- data %>%
    as.data.frame() %>%
    dplyr::filter(PG.MaxLFQ.Quality > params$pgScore &
      Empirical.Quality > params$eqScore)

  cat("\nPG.MaxLFQ.Quality >", params$pgScore,
    "\nEmpirical.Quality >", params$eqScore)

  return(result)
}

FilterBySample <- function(data) {
  # result <- data %>%
  #   as.data.frame() %>%
  #   dplyr::filter(Run != params$sampleToRemove)

  cat("\nSample removed:", params$samplesToRemove)

  cols <- colnames(data)

  return(data[, (!cols %in% params$samplesToRemove)])
}

FilterByUniqueGenes <- function(data) {

  result <- data %>%
    diann::diann_matrix(id.header = "Protein.Group",
      quantity.header = "Genes.MaxLFQ.Unique",
      proteotypic.only = TRUE,
      pg.q = 0.01)

  cat("\nFilter by unique genes using Diann_Matrix")
  return(result)
}

FilterByMissingness <- function(data) {


  MeanOfMissing <- function(x) {
    return(sum(is.na(x)) / length(x))
    # return(mean(is.na(x)))
  }
  df <- as.data.frame(data)


  result <- dplyr::mutate(df, prot_miss = apply(df, 1, MeanOfMissing)) %>%

    dplyr::filter(prot_miss <= params$threshold) %>%
    dplyr::select(-prot_miss)

  cat("\nMissingness threshold <=", params$threshold)

  return(as.matrix(result))
}

CleanDiannReport <- function() {

  diannReport <- DiannReport(labels) # Not sure if the best approach is to get it inside the function or pass as argument

  fileName <- "cleanDiannReport"

  result <- diannReport %>%
    FilterByScore() %>%
    FilterByUniqueGenes() %>%
    FilterBySample() %>%
    FilterByMissingness()
  # No console da a entender que o FilterBySample está sendo chamado antes do FilterByScore, mas não é o caso. É só uma anomalia do %>%.

  cat("\n")
  cat(cleanDiannReport, "were loaded")

  return(result)
}

CreateImputationMatrix <- function(
    override = TRUE,
    imputationMethod = "rf",
    mValue = 1,
    maxitValue = 10,
    seedValue = 50
    ) {
  filenameImputation <- paste0("imputedMatrix_", imputationMethod, ".rds")
  filenameResult <- paste0("result_", filenameImputation)

  filesExists <- (file.exists(filenameImputation) | file.exists(filenameResult))

  if (!(override) & filesExists) {
    cat("\nLoad file:", filenameResult)
    invisible(read_rds(filenameResult))
  } else {
    uniqueGenesCleaned <- CleanDiannReport()

    matrixForImputation <- log2(uniqueGenesCleaned + 1) %>%
      as.data.frame() %>%
      rownames_to_column(var = "protein") # %>%
    # janitor::clean_names() #acho que só precisa do clean_names se eu for plotar a matrix de imputação

    cat("\nCreating the imputed matrix.\n\nThis is going to take a while.\n")

    imputedMatrix <- mice::mice(
      matrixForImputation,
      method = imputationMethod,
      m = mValue,
      maxit = maxitValue,
      seed = seedValue,
      printFlag = FALSE
    )

    result <- mice::complete(imputedMatrix)

    cat("\nCreate files:\n", filenameImputation, "\n", filenameResult)
    write_rds(imputedMatrix, file = filenameImputation)
    write_rds(result, file = filenameResult)

    invisible(result)
  }
}

# cat("\n\nHelper functions were loaded.\n")
```


```{r}

for (c in 1:26) {

  for (i in 1:636) {
    if (!identical(pedro_result_imputed[i, c], complete_mtx[i, c])) {
      cat("\n problema em:", i, c)
    }
  }
}
cat("\ndone")
```



# Graph functions ----
```{r}
GenBarGraph <- function(data, xValue, yValue, condition, xLabel, nmax) {
  ggplot(data, aes(
    y = yValue,
    x = xValue,
    fill = condition
  )) +
    geom_bar(
      stat = "identity",
      position = "dodge",
      show.legend = FALSE
    ) +
    scale_fill_manual(values = colors) +
    geom_text(
      aes(
        label = xLabel,
        hjust = ifelse(xLabel > nmax, 1.1, -0.15)
      ),
      color = "black",
      size = 7, nudge_x = -0.5
    ) +
    labs(
      y = NULL,
      x = xLabel,
      fill = NULL
    ) +
    theme(
      text = element_text(size = 17),
      axis.text.x = element_text(
        angle = 90, vjust = 0.5, hjust = 1
      ),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )
}


SparsityPlot <- function(df) {
  df %>%
    as.data.frame() %>%
    naniar::vis_miss() +
    labs(
      x = NULL,
      y = "Number of proteins"
    ) +
    theme(
      text = element_text(size = 20),
      axis.text.y = element_text(color = "black", vjust = 1),
      axis.text.x = element_text(
        angle = 90, color = "black"
      ),
      line = element_blank(),
      panel.background = element_blank()
    )
}


cat("\n\nGraph functions were loaded.\n")
```

# Graph: Precursor x RT / Density Map ----
```{r}
# Reconstruction of the ion chromatograms, the precursor quantity is
#  plotted over the retention time (min) for each sample.
GraphPrecursorRT_mzMapDensity <- function() {
  diannReport <- DiannReport(labels)

  precursorRT <- diannReport %>%
    ggplot(aes(x = RT, y = Precursor.Quantity)) +
    geom_line(aes(color = condition), show.legend = FALSE) +
    scale_color_manual(values = colors) +
    labs(
      x = "Retention time (min)",
      y = "Precursor quantity",
      color = NULL
    ) +
    facet_wrap(~Run, ncol = 6, scales = "free") +
    theme(
      strip.background = element_blank(),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )

  # For the m/z map, the density of ions collected is plotted over
  # the scan range (m/z) for each sample.
  mzMapDensity <- diannReport %>%
    ggplot(aes(x = RT, y = Precursor.Mz)) +
    ggpointdensity::geom_pointdensity(size = 0.1) +
    viridis::scale_color_viridis(option = "H") +
    scale_x_continuous(limits = c(0, 90)) +
    labs(
      x = "Retention time (min)",
      y = "Scan range (m/z)",
      color = NULL
    ) +
    facet_wrap(~Run, scales = "free", ncol = 6) +
    theme(
      strip.background = element_blank(),
      legend.position = "bottom",
      legend.key.width = unit(1.5, "cm"),
      legend.key.height = unit(0.25, "cm"),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )


  precursorRT_and_mzMapDensity <- (precursorRT / mzMapDensity) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  ggsave(
    filename = paste(quote(precursorRT_and_mzMapDensity), ".png", sep = ""),
    path = "plots",
    plot = precursorRT_and_mzMapDensity,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat("\n\nGraph ", quote(precursorRT_and_mzMapDensity), ".png were created.\n", sep = "")

  # return(precursorRT_and_mzMapDensity)
}

GraphPrecursorRT_mzMapDensity()
```

# Graph: Peptides | Proteins ----
```{r}
# Counting the number of unique peptides and proteins per run
GraphNumberOfPeptidesAndProteins <- function(nmaxPeptides, nmaxProteins) {
  diannReport <- DiannReport(labels)

  diannReportByRun <- diannReport %>%
    dplyr::group_by(Run, condition) %>%
    dplyr::summarise(
      n_peptides = n_distinct(Stripped.Sequence),
      n_proteins = n_distinct(Protein.Ids))

  totalUniquePeptides <- n_distinct(diannReport$Stripped.Sequence)
  totalUniqueProteins <- n_distinct(diannReport$Protein.Ids)

  # Create the peptides graph
  peptidesPlot <- diannReportByRun %>%
    ggplot(aes(y = Run, x = n_peptides, fill = condition)) +
    geom_bar(stat = "identity", position = "dodge", show.legend = FALSE) +
    scale_fill_manual(values = colors) +
    geom_text(
      aes(
        label = n_peptides,
        hjust = ifelse(n_peptides > nmaxPeptides, 1.1, -0.15)
      ),
      color = "black", size = 7, nudge_x = -0.5, fontface = "bold"
    ) +
    labs(y = NULL, x = "Number of peptides", fill = NULL) +
    theme(
      text = element_text(size = 25),
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )

  # Create the proteins graph
  proteinsPlot <- diannReportByRun %>%
    ggplot(aes(y = Run, x = n_proteins, fill = condition)) +
    geom_bar(stat = "identity", position = "dodge", show.legend = FALSE) +
    scale_fill_manual(values = colors) +
    geom_text(
      aes(
        label = n_proteins,
        hjust = ifelse(n_proteins > nmaxProteins, 1.1, -0.15)
      ),
      color = "black", size = 7, nudge_x = -0.5, fontface = "bold"
    ) +
    labs(y = NULL, x = "Number of proteins", fill = NULL) +
    theme(
      text = element_text(size = 25),
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )


  # Concatenate peptides plot and proteins plot
  number_of_peptides_and_proteins <- (peptidesPlot | proteinsPlot) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  # Save file
  ggsave(
    filename = paste(quote(number_of_peptides_and_proteins), ".png", sep = ""),
    path = "plots",
    plot = number_of_peptides_and_proteins,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat("\nGraph ", quote(number_of_peptides_and_proteins), ".png were created.\n",
    "Total number of unique  peptides: ", totalUniquePeptides,
    "\nTotal number of unique proteins: ", totalUniqueProteins, "\n",
    sep = ""
  )

  # return(peptidesPlot)
}

GraphNumberOfPeptidesAndProteins(nmaxPeptides = 8200, nmaxProteins = 1900)
```

# Graph: Sparsity Matrix ----
```{r}
# Genes.MaxLFQ.Unique: matriz de abundância de intensidade normalizada com algoritmo MAX LFQ sendo calculada a partir de peptídeos únicos (peptídeos que dão match apenas com uma proteína)

GraphSparsityMatrix <- function() {
  diannReport <- DiannReport(labels)

  # Create sparsity plot with unique genes UNFILTERED
  # uniqueGenes <- diann::diann_matrix(
  #   diannReport,
  #   id.header = "Protein.Group",
  #   quantity.header = "Genes.MaxLFQ.Unique",
  #   proteotypic.only = T,
  #   pg.q = .01
  # )

  uniqueGenes <-  FilterByUniqueGenes(diannReport) # me retorna uma matrix
  sparsityPlotRaw <- SparsityPlot(uniqueGenes) # converto para df dentro da func plot


  # Create a sparsity plot with unique genes FILTERED
  uniqueGenesFiltered <- diannReport %>%
    FilterByScore() %>%
    FilterBySample() %>%
    FilterByUniqueGenes()

  sparsityPlotFiltered <- SparsityPlot(uniqueGenesFiltered)


  # Create a sparsity plot with unique genes REDUCED and FILTERED

  uniqueGenesCleaned <- CleanDiannReport()
  sparsityPlotCleaned <- SparsityPlot(uniqueGenesCleaned)


  sparsity_matrix <- (sparsityPlotRaw | sparsityPlotFiltered | sparsityPlotCleaned) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  ggsave(
    filename = paste(quote(sparsity_matrix), ".png", sep = ""),
    path = "plots",
    plot = sparsity_matrix,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat("\nGraph ", quote(sparsity_matrix), ".png were created.\n", sep = "")

}

GraphSparsityMatrix()
```

# Graph: QuanUMS Evaluation ----
```{r}
GraphQuantUMS <- function() {

  diannReport <- DiannReport(labels)

  lowScoresPeptide <- diannReport %>%
    dplyr::filter(PG.MaxLFQ.Quality < params$pgScore &
      Empirical.Quality < params$eqScore) %>% # Quero ver o que foi cortado, é diferente da função FilterByScore, onde eu quero ter só o que passou  no filtro
    dplyr::group_by(Run) %>%
    dplyr::summarise(
      n = n_distinct(Stripped.Sequence))

  quantUMS <- diannReport %>%
    ggplot(aes(x = PG.MaxLFQ.Quality,
      y = Empirical.Quality)) +

    geom_pointdensity(size = 0.5) +

    geom_vline(xintercept = 0.75, linetype = "dashed", color = "black") +
    geom_hline(yintercept = 0.75, linetype = "dashed", color = "black") +
    viridis::scale_color_viridis(option = "plasma") +

    geom_text(data = lowScoresPeptide,
      aes(x = 0.25, y = 0.35, label = n),
      hjust = -0.1, vjust = 0.5,
      size = 9, fontface = "bold",
      color = "red", show.legend = FALSE) +

    labs(title = "QuantUMS scores for feature selection",
      x = "pgQ Score",
      y = "eQ Score",
      color = NULL) +

    facet_wrap(~Run, ncol = 6) +
    theme(plot.title = element_text(size = 30,
      face = "bold", hjust = 0.5),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 20),
    text = element_text(size = 20),
    axis.title = element_text(size = 30),
    axis.text.x = element_text(color = "black",
      angle = 90, vjust = 0.5, hjust = 1),
    legend.position = "none",
    panel.border = element_rect(color = "black", fill = NA),
    panel.background = element_rect(fill = "white")
    )

  ggsave(
    filename = paste(quote(quantUMS), ".png", sep = ""),
    path = "plots",
    plot = quantUMS,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat("\nGraph ", quote(quantUMS), ".png were created.\n", sep = "")

  # return(quantUMS)
}

GraphQuantUMS()
```

# Graph: Cosine Similarity ----
```{r}
GraphCosSimilarity <- function() {

  cosineSimilarity <- CreateImputationMatrix(override = FALSE) %>%
    column_to_rownames("protein") %>%
    as.matrix() %>%
    lsa::cosine() %>%
    as.data.frame() %>%
    rownames_to_column(var = "Sample") %>%
    pivot_longer(-Sample, names_to = "Match") %>% # não entendi essa desgraça

    dplyr::mutate(Similarity = "Cosine similarity",
      Sample = factor(Sample, levels = unname(labels)),
      Match = factor(Match, levels = unname(labels))) %>%

    ggplot() +
    geom_tile(aes(x = Sample, y = Match, fill = value)) +
    viridis::scale_fill_viridis(option = "E") +
    labs(title = "Similarity matrix",
      x = NULL,
      y = NULL,
      fill = "Cosine similarity") +
    # theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
      text = element_text(size = 20),
      axis.text.x = element_text(angle = 90,
        hjust = 1, vjust = 0.5, color = "black"),
      axis.text.y = element_text(angle = 0,
        hjust = 1, vjust = 0.5, color = "black"),
      legend.position = "bottom",
      legend.title.position = "top",
      legend.title = element_text(hjust = 0.5),
      legend.key.width = unit(2.5, "cm"),
      legend.key.height = unit(0.3, "cm"),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank())

  ggsave(
    filename = paste(quote(cosineSimilarity), ".png", sep = ""),
    path = "plots",
    plot = cosineSimilarity,
    width = 24, height = 20,
    units = "in", dpi = 300)

  cat("\nGraph ", quote(cosineSimilarity), ".png were created.\n", sep = "")

  return(cosineSimilarity)
}

GraphCosSimilarity()

# kmeans_clusters | pca_plot) / (cosine_similarity | cv_plot) -->
```

# Graph: Principal Component Analysis (PCA) by K-means [Tá diferente, mas não sei pq :c]
```{r}

# TODO:Talvez o problema seja os nomes sem _, um janitor::clean_names() pode resolver..
GraphPCA_Kmeans <- function(numberOfClusters = count(colors)) {
  pcaComplete <- CreateImputationMatrix() %>%
    column_to_rownames("protein") %>%
    t() %>%
    prcomp()

  pcaTwoDimensions <- pcaComplete$x[, 1:2]
  # set.seed(123)

  kmeans_clusters <- fviz_nbclust(pcaTwoDimensions,
    FUNcluster = kmeans,
    method = "wss") +

    geom_point(size = 4, color = "steelblue") +
    geom_vline(xintercept = numberOfClusters, linetype = "dashed") +
    theme_minimal() +
    labs(title = "Optimal number of clusters") +
    theme(plot.title = element_text(hjust = 0.5),
      text = element_text(color = "black", size = 20),
      title = element_text(color = "black", size = 20, face = "bold", hjust = 0.5),
      axis.text = element_text(color = "black"),
      axis.title = element_text(color = "black", face = "bold"),
      axis.ticks = element_line(color = "black"),
      panel.border = element_rect(color = "black", fill = NA))

  kMeansPCA <- kmeans(pcaTwoDimensions, centers = numberOfClusters)

  pcaPlot <- fviz_pca_ind(pcaComplete,
    geom = c("point", "text"),
    habillage = kMeansPCA$cluster,
    labelsize = 7, pointsize = 3,
    palette = colors,
    addEllipses = FALSE,
    ggtheme = theme_classic(),
    repel = TRUE) +

    labs(title = "PCA clustered by k-means") +
    theme_minimal() +

    theme(plot.title = element_text(hjust = 0.5),
      text = element_text(color = "black", size = 20),
      title = element_text(color = "black", size = 20,
        face = "bold", hjust = 0.5),
      axis.text = element_text(color = "black"),
      axis.title = element_text(color = "black", face = "bold"),
      strip.background = element_rect(fill = "grey90"),
      strip.text = element_text(face = "bold"),
      legend.title = element_text(face = "bold", hjust = 0.5),
      legend.title.position = "top",
      legend.position = "none",
      panel.border = element_rect(color = "black", fill = NA))


  kMeans_PCA <- (kmeans_clusters | pcaPlot) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  ggsave(
    filename = paste(quote(kMeans_PCA), ".png", sep = ""),
    path = "plots",
    plot = kMeans_PCA,
    width = 24, height = 10,
    units = "in", dpi = 300
  )

  cat("\n\nGraph ", quote(pcaPlot_and_kMeansPCA), ".png were created.\n", sep = "")

}

GraphPCA_Kmeans(numberOfClusters = params$numberOfClusters)
```

# Graph: Coefficient of Variation [REFACTOR!] ----
```{r}

GraphCoefficientOfVariation <- function() {

  imputationResult <- CreateImputationMatrix()

  conditions <- unique(DiannReport(labels)$condition)
  CVs <- data.frame()

  cat("\nCalculating Coefficient of Variation...")

  for (condition in conditions) {
    # TODO: olha a gambiarra kkkkkk
    CVs <- bind_rows(CVs,
      CV_Matrix(imputationResult,
        gambiarra = paste0("^", str_replace(condition, "\\+", "\\\\+"), " r[0-9]+"),
        condition = condition))
  }

  CVs <- CVs %>%
    dplyr::mutate(condition = factor(condition,
      levels = unique(str_remove(unname(labels), " r[0-9]+"))))


  CVplot <- CVs %>%
    ggplot(aes(y = condition, x = cv, fill = condition)) +
    geom_violin(linewidth = 0.2) +
    geom_boxplot(width = 0.2, fill = "white",
      linewidth = 0.2, outlier.alpha = 0.5) +
    geom_vline(xintercept = 20, linetype = "dashed", color = "black") +
    scale_fill_manual(values = colors) +
    labs(
      y = NULL,
      x = "Coefficient of variation (%)",
      fill = NULL) +
    theme_linedraw() +
    theme(
      legend.position = "none",
      axis.title = element_text(size = 20, face = "bold"),
      axis.text = element_text(color = "black", size = 20, face = "bold"),
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
      axis.ticks = element_line(),
      line = element_blank(),
      strip.background = element_blank(),
      strip.text = element_text(size = 20, face = "bold", color = "black"))

  ggsave(
    filename = paste(quote(CVplot), ".png", sep = ""),
    path = "plots",
    plot = CVplot,
    width = 12, height = 10,
    units = "in", dpi = 300)

  cat("\n\nGraph ", quote(CVplot), ".png were created.\n", sep = "")
}
GraphCoefficientOfVariation()
```





# Graph: Bland-Altman [TODO] ----
```{r}
# TODO:
```

# Graph: Distribution of proteins of interest [TODO] ----
```{r}
# TODO:
```

