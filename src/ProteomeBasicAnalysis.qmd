---
title: "Proteoma Basic Analysis"
author: "Alison Felipe Alencar Chaves e Pedro Galdiano de Castro"
execute:
  echo: false
  warning: false
  message: false
format: html
code-fold: true
editor_options:
  chunk_output_type: console
---

# 1) Load packages dependencies
```{r}
library(diann) # to extract the MaxLFQ matrix from DIANN report
library(arrow) # to read the report.parquet file
library(here) # to avoid the need for use the path while loading the data
library(tidyverse) # to do the data wrangling, plots, etc...
library(janitor) # to clean the column names
library(ggpointdensity) # to reconstruct the m/z density map
library(naniar) # for sparsity analysis
library(factoextra) # to plot the PCA
library(patchwork) # to combine plots
library(lsa) # to calculate the cosine similarity
library(ggvenn) # to plot the Venn diagram
library(paletteer) # to use the nice color palette
library(ggtext) # to provide Markdown and HTML formatting in ggplot2
library(ggrepel) # to avoid the overlapping of the labels in the plots
library(kableExtra) # to format the tables
library(limma) # to calculate the differential abundance
library(DIAgui) # to extract iBAQ values

cat("\n\n1) All packages were activated.\n")
```

# 2) Global variables
```{r}
#You should only need to change this chunk of code, please don't break it.

  
params <- list(
#This map should be ordered by the sample-name (code = Sample name r1), 
#this will define the order everything will be ploted
  labels = c(
    P2_01 =  "NaCl r1",
    P2_02 = "NaCl r2",
    P2_03 =  "NaCl r3",
    
    P2_04 = "Actinonin 15mg r1",
    P2_05 =  "Actinonin 15mg r2",
    P2_06 = "Actinonin 15mg r3",
    P1_04 = "Actinonin 30mg r1",
    P1_05 =  "Actinonin 30mg r2",
    
    P2_11 = "JPM OEt 50mg r1",
    P2_12 =  "JPM OEt 50mg r2",
    P1_10 =  "JPM OEt 100mg r1",
    P1_11 = "JPM OEt 100mg r2",
    P1_12 =  "JPM OEt 100mg r3",
    
    P1_02 = "Venom r1",
    P1_03 =  "Venom r2",
    
    P2_07 =  "Ven & Actn 15mg r1",
    P2_08 = "Ven & Actn 15mg r2",
    P2_09 =  "Ven & Actn 15mg r3",
    
    P1_07 = "Ven & Actn 30mg r1",
    P1_08 =  "Ven & Actn 30mg r2",
    P1_09 = "Ven & Actn 30mg r3",
    
    P2_13 = "Ven & JPMOEt 50mg r1",
    P2_14 =  "Ven & JPMOEt 50mg r2",
    P2_15 = "Ven & JPMOEt 50mg r3",
    
    P1_13 = "Ven & JPMOEt 100mg r1",
    P1_14 =  "Ven & JPMOEt 100mg r2",
    P1_15 = "Ven & JPMOEt 100mg r3"
  ),
  
  #report.parquet directory
  directoryReport = "C:/Users/pgc/Documents/ic_urina/Proteoma_Analysis/data/input/report.parquet",
  
  #id_mapping.tsv diretory
  directoryIDmapping = "./id_mapping.tsv",
  
  #Params to filter by
  pgScore = 0.75, #protein score
  eqScore = 0.75, #empirical score
  threshold = 0.3, # % of missingness alowed
  samplesToRemove = c(""), #samples you want to remove
  setSeed = 333, #random seed
  
  #Fix the plot in the number of proteins and peptides plot
  nMaxPeptides = 8200,
  nMaxProteins = 1200,
  
  #Params to create imputation Matrix (Diann_Matrix)
  imputMethod = "rf", #method of imputation
  imputM = 1, #M
  imputMaxit = 10, #Maxit
  imputSeed = 50, #Seed
  imputOverride = FALSE, #Override imputed matrix
  
  numberOfClusters = 4, #Number of clusters
  
  regexString = " r[0-9]+", #Regex to remove replicates and create conditions
  
  #If more or different colors are need just go to "colorbrewer2.org"
  colors = c(
    "#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99",
    "#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a"),
  
  
  # Which samples you want to compare, should follow the example:
  # Actinonin_15mg_vs_NaCl = "Actinonin_15mg - NaCl"
  samplesToCompare = list(
    Actinonin_15mg_vs_NaCl = "Actinonin_15mg - NaCl",
    Actinonin_30mg_vs_NaCl = "Actinonin_30mg - NaCl",
    
    JPMOEt_50mg_vs_NaCl = "JPM_OEt_50mg - NaCl",
    JPMOEt_100mg_vs_NaCl = "JPM_OEt_100mg - NaCl",
    
    Venom_vs_NaCl = "Venom - NaCl",
    
    Ven_Actn_15mg_vs_NaCl = "Ven_Actn_15mg - NaCl",
    Ven_Actn_30mg_vs_NaCl = "Ven_Actn_30mg - NaCl",
    
    Ven_jPMOEt_50mg_vs_NaCl = "Ven_JPMOEt_50mg - NaCl",
    Ven_jPMOEt_100mg_vs_NaCl = "Ven_JPMOEt_100mg - NaCl",
    
    Actinonin_15mg_vs_Actinonin_30mg = "Actinonin_15mg - Actinonin_30mg",
    JPMOEt_50mg_vs_JPMOEt_100mg = "JPM_OEt_50mg - JPM_OEt_100mg",
    
    Ven_Actn_15mg_vs_Venom = "Ven_Actn_15mg - Venom",
    Ven_Actn_30mg_vs_Venom = "Ven_Actn_30mg - Venom",
    
    Ven_jPMOEt_50mg_vs_Venom = "Ven_JPMOEt_50mg - Venom",
    Ven_jPMOEt_100mg_vs_Venom = "Ven_JPMOEt_100mg - Venom"
  ),
  
  #Genes you wanto to highlight in th e bland-altman plot
  genesToHighlight_blandAltman = c(
    "Il1rap", "Lcn2", "Slc47a1", "Chia", "Mup17", "Mup3","Umod", "Mup20",
    "Xpnpep2",  "Nectin4", "Esam", "Alb","Asah1", "Smpd1", "Smpdl3a", "Apoe",
    "Apoa1", "Apoa2","B2m", "Vcam1", "Blvrb", "Orm2", "Orm1", "Mup4", "Obp1a",
    "Serpina6", "C8g", "Ngp", "Cd36", "Hba", "Hbb-b1","Hbb-b2","Chil3", "Apcs",
    "Hp", "Mug1", "Serpina1b","Serpina3k", "Bcam", "Cdh1", "Cdh11", "Ceacam1",
    "Cd248","Cfi", "Fgg", "Fga", "Fgb", "Kng1", "Lum", "Retnla","Cd200",
    "Cd44","Cd48", "Cd36", "Cltrn", "Cp", "Cspg4","Cst3", "Ctsd", "Ctse",
    "Ctso","Dag1", "Dsc1"),
  
  #Genes you wanto to highlight in th e proteins comparison plot
  genesToHighlight_proteinsComparison = c(
    "Il1rap", "Lcn2", "Slc47a1","Mup17", "Mup3", "Mup20",  "Nectin4", "Esam",
    "Alb", "Smpd1","Apoe", "Apoa1", "Apoa2", "Vcam1","Blvrb", "Orm2", "Orm1",
    "Mup4", "Serpina6","C8g", "Cd36", "Hba", "Hbb-b1", "Hbb-b2","Chil3",
    "Apcs", "Hp","Mug1", "Serpina1b", "Serpina3k","Bcam", "Cdh1", "Cfi",
    "Fgg", "Fga", "Fgb", "Kng1", "Lum","Cd36", "Cp", "Cspg4", "Cst3", "Ctsd",
    "Ctse", "Ctso", "Dag1")
  
)


#Check if the labels name are valid, do not check for every possible case
checkLabels <- function() { # OK
  conditions = unique(stringr::str_remove_all(params$labels, params$regexString))

  for (condition in conditions) {
    occurrences = sum(stringr::str_detect(conditions, condition))
    
    if (occurrences > 1) {
      cat("\nThis name should be unique and not a part of another name:", 
          condition,
          "\nPlease, rename.")
      break
    } else if (str_detect(condition, "\\+|\\-|\\.|\\%|\\(|\\)|\\[|\\]|\\~")) {
            cat("\nThose symbols cannot be used (+,-,.,%,(,),[,],~):",
          condition,
          "\nPlease, rename.")
      break
    }
  }
}

cat("\n\n2) Global variables were loaded.\n\n")
checkLabels()
```

# 3) Helper functions ----
```{r}
# Return a dataset with the coefficients of variation
CV_Matrix <- function(data, condition) {

  data <- data %>% as.data.frame() %>% 
    rownames_to_column(var = "protein")
  
  selected <- dplyr::select(
    data,
    protein,
    str_subset(colnames(data), condition)
    ) %>% rowwise()

  mutated <- dplyr::mutate(selected,
    across(where(is.numeric), ~ 2^(.) - 1),
    cv = 100 *
      (
        sd(c_across(where(is.numeric)), na.rm = TRUE) /
          mean(c_across(where(is.numeric)), na.rm = TRUE)
      ),
    condition = condition
  )

  
  return(dplyr::select(mutated, protein, cv, condition))
}

# Generate the diannReport.rds from report.parquet file
DiannReport <- function() {

  report <- arrow::read_parquet(params$directoryReport)

  reportFiltered <- dplyr::filter(
    report,
    Lib.PG.Q.Value <= 0.01 &
      Lib.Q.Value <= 0.01 &
      PG.Q.Value <= 0.01
  )
  
  reportRecoded <- dplyr::mutate(reportFiltered,
    Run = recode(Run, !!!params$labels),
    Run = factor(Run, levels = unname(params$labels)),
    condition = str_remove(Run, params$regexString),
    File.Name = Run,
    peptide_length = nchar(Stripped.Sequence)
  )

  diannReport <- dplyr::filter(
    reportRecoded,
    str_detect(Protein.Names, "MOUSE")
  )

  cat("\ndiannReport were loaded.")

  return(diannReport)
}

#Filter by scores
FilterByScore <- function(data) {

  result <- data %>%
    as.data.frame() %>%
    dplyr::filter(PG.MaxLFQ.Quality > params$pgScore &
      Empirical.Quality > params$eqScore)

  cat("\nPG.MaxLFQ.Quality >", params$pgScore,
    "\nEmpirical.Quality >", params$eqScore)

  return(result)
}

#Filter out samples
FilterBySample <- function(data) {
  
  cat("\nSample removed:", params$samplesToRemove)

  cols <- colnames(data)
  return(data[, (!cols %in% params$samplesToRemove)])
}

#Create the Diann Matrix
FilterByDiannMatrix <- function(data) {

  result <- data %>%
    diann::diann_matrix(id.header = "Genes",
      quantity.header = "Genes.MaxLFQ.Unique",
      proteotypic.only = TRUE,
      pg.q = 0.01)

  cat("\n\nFilter by unique genes using Diann_Matrix")
  return(result)
}

#Filter by threshold
FilterByMissingness <- function(data) {


  MeanOfMissing <- function(x) {
    return(mean(is.na(x)))
  }
  
  df <- as.data.frame(data)

  result <- dplyr::mutate(df, prot_miss = apply(df, 1, MeanOfMissing)) %>%

    dplyr::filter(prot_miss <= params$threshold) %>%
    dplyr::select(-prot_miss)

  cat("\nMissingness threshold <=", params$threshold)

  return(as.matrix(result))
}


#Apply every filter to the diann report
CleanDiannReport <- function() {

  diannReport <- DiannReport()

  fileName <- "cleanDiannReport"

  result <- diannReport %>%
    FilterByScore() %>%
    FilterByDiannMatrix() %>%
    FilterBySample() %>%
    FilterByMissingness()
  #In the console, looks like FilterBySample is called before FilterByScore
  #That's not the case. This is just a anomaly of %>% 
  
  cat(paste0("\n",fileName, "were created."))

  return(result)
}

StepWiseImputation <- function(
  protein_matrix,
  group_vector,
  use_mean_for_low = TRUE,
  abundance_threshold = NULL,
  shift_value = -1,
  noise_type = "normal",
  noise_sd = 0.1,
  noise_range = c(-0.2, 0.2),
  min_detection_method = "global",
  seed = params$setSeed,
  verbose = TRUE
) {
  set.seed(seed)
  result_matrix <- protein_matrix
  unique_groups <- unique(group_vector)
  missing_protein_log <- data.frame()

  # Step 1: Handle completely missing proteins within groups
  if (verbose) {
    cat("Step 1: Detecting and handling completely missing proteins...\n")
  }

  for (protein in 1:nrow(protein_matrix)) {
    protein_values <- protein_matrix[protein, ]

    # Determine minimum value based on method
    if (min_detection_method == "global") {
      min_value <- min(protein_values, na.rm = TRUE)
    } else {
      # Group-wise: find minimum among groups that have this protein
      group_mins <- sapply(unique_groups, function(g) {
        g_indices <- which(group_vector == g)
        g_values <- protein_values[g_indices]
        if (all(is.na(g_values))) {
          return(Inf)
        }
        return(min(g_values, na.rm = TRUE))
      })
      min_value <- min(group_mins[!is.infinite(group_mins)])
    }

    # Skip if all values are missing for this protein
    if (is.infinite(min_value)) {
      next
    }

    # Check each group for complete missingness
    for (group in unique_groups) {
      group_indices <- which(group_vector == group)
      group_protein_values <- protein_values[group_indices]

      # If all values in this group are missing
      if (all(is.na(group_protein_values))) {
        if (verbose) {
          cat(sprintf(
            "  Protein %d completely missing in group %s (min_value: %.3f)\n",
            protein,
            group,
            min_value
          ))
        }

        # Log this imputation
        missing_protein_log <- rbind(
          missing_protein_log,
          data.frame(
            protein = protein,
            group = group,
            min_value = min_value,
            shifted_value = min_value + shift_value
          )
        )

        # Calculate shifted value
        shifted_value <- min_value + shift_value

        # Generate values with noise for this group
        n_samples <- length(group_indices)

        if (noise_type == "normal") {
          noise <- rnorm(n_samples, mean = 0, sd = noise_sd)
        } else if (noise_type == "uniform") {
          noise <- runif(n_samples, min = noise_range[1], max = noise_range[2])
        }

        imputed_values <- shifted_value + noise

        # Assign to result matrix
        result_matrix[protein, group_indices] <- imputed_values
      }
    }
  }

  # Step 2: Main imputation for remaining missing values
  if (verbose) {
    cat("Step 2: Performing main imputation...\n")
  }

  # Calculate overall abundance threshold if not provided
  if (is.null(abundance_threshold)) {
    abundance_threshold <- median(result_matrix, na.rm = TRUE)
  }

  for (group in unique_groups) {
    if (verbose) {
      cat("  Processing group", group, "...\n")
    }

    group_indices <- which(group_vector == group)
    group_data <- result_matrix[, group_indices, drop = FALSE]

    if (any(is.na(group_data))) {
      for (protein in 1:nrow(group_data)) {
        protein_data <- group_data[protein, ]

        if (any(is.na(protein_data))) {
          non_na_values <- protein_data[!is.na(protein_data)]

          if (length(non_na_values) == 0) {
            # All missing - use threshold value (shouldn't happen after step 1)
            protein_data[] <- abundance_threshold
          } else if (length(non_na_values) == 1) {
            # Only one value - use it
            protein_data[is.na(protein_data)] <- non_na_values[1]
          } else {
            # Multiple values available
            protein_median <- median(non_na_values)

            if (
              use_mean_for_low &&
                !is.na(protein_median) &&
                protein_median <= abundance_threshold
            ) {
              # Low abundance - use mean
              protein_mean <- mean(non_na_values)
              protein_data[is.na(protein_data)] <- protein_mean
            } else {
              # High abundance - try mice, fallback to mean
              temp_df <- data.frame(
                value = protein_data,
                group_id = rep(1, length(protein_data))
              )

              tryCatch(
                {
                  mice_result <- mice::mice(
                    temp_df[, "value", drop = FALSE],
                    m = 1,
                    method = "pmm",
                    printFlag = FALSE
                  )
                  completed <- complete(mice_result, 1)
                  protein_data <- completed[, 1]
                },
                error = function(e) {
                  # Fallback to mean
                  protein_mean <- mean(non_na_values)
                  protein_data[is.na(protein_data)] <<- protein_mean
                }
              )
            }
          }

          result_matrix[protein, group_indices] <- protein_data
        }
      }
    }
  }

  # Return results
  return(list(
    imputed_data = result_matrix,
    missing_protein_log = missing_protein_log,
    parameters = list(
      shift_value = shift_value,
      noise_type = noise_type,
      noise_sd = noise_sd,
      min_detection_method = min_detection_method
    )
  ))
}

cat("\n\n3) Helper functions were loaded.\n")
```

# 4) Graph functions ----
```{r}

#Generic way of creating a bar graph
GenBarGraph <- function(data, xValue, yValue, condition, xLabel, nmax) {
  ggplot(data, aes(
    y = yValue,
    x = xValue,
    fill = condition
  )) +
    geom_bar(
      stat = "identity",
      position = "dodge",
      show.legend = FALSE
    ) +
    scale_fill_manual(values = params$colors) +
    geom_text(
      aes(
        label = xLabel,
        hjust = ifelse(xLabel > nmax, 1.1, -0.15)
      ),
      color = "black",
      size = 7, nudge_x = -0.5
    ) +
    labs(
      y = NULL,
      x = xLabel,
      fill = NULL
    ) +
    theme(
      text = element_text(size = 17),
      axis.text.x = element_text(
        angle = 90, vjust = 0.5, hjust = 1
      ),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )
}


#Generic way of creating a sparsity plot
SparsityPlot <- function(df) {
  df %>%
    as.data.frame() %>%
    naniar::vis_miss() +
    labs(
      x = NULL,
      y = "Number of proteins"
    ) +
    theme(
      text = element_text(size = 20),
      axis.text.y = element_text(color = "black", vjust = 1),
      axis.text.x = element_text(
        angle = 90, color = "black"
      ),
      line = element_blank(),
      panel.background = element_blank()
    )
}


#Theme update
  theme_update(
    text = element_text(color = "black", size = 20),
    axis.text = element_text(color = "black"),
    axis.title = element_text(color = "black", face = "bold"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.title = element_text(face = "bold", hjust = 0.5),
    legend.title.position = "top"
)  
  


cat("\n\n4) Graph functions were loaded.\n")
```

# 5) Graph: Precursor x RT / Density Map ----
```{r}
#Reconstruction of the ion chromatograms, the precursor quantity is
#plotted over the retention time (min) for each sample.
GraphPrecursorRT_mzMapDensity <- function() {
  diannReport <- DiannReport()

  precursorRT <- diannReport %>%
    ggplot(aes(x = RT, y = Precursor.Quantity)) +
    geom_line(aes(color = condition), show.legend = FALSE) +
    scale_color_manual(values = params$colors) +
    labs(
      x = "Retention time (min)",
      y = "Precursor quantity",
      color = NULL
    ) +
    facet_wrap(~Run, ncol = 6, scales = "free") +
    theme(
      strip.background = element_blank(),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )

  # For the m/z map, the density of ions collected is plotted over
  # the scan range (m/z) for each sample.
  mzMapDensity <- diannReport %>%
    ggplot(aes(x = RT, y = Precursor.Mz)) +
    ggpointdensity::geom_pointdensity(size = 0.1) +
    viridis::scale_color_viridis(option = "H") +
    scale_x_continuous(limits = c(0, 90)) +
    labs(
      x = "Retention time (min)",
      y = "Scan range (m/z)",
      color = NULL
    ) +
    facet_wrap(~Run, scales = "free", ncol = 6) +
    theme(
      strip.background = element_blank(),
      legend.position = "bottom",
      legend.key.width = unit(1.5, "cm"),
      legend.key.height = unit(0.25, "cm"),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )


  precursorRT_and_mzMapDensity <- (precursorRT / mzMapDensity) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  ggsave(
    filename = paste0("5-", quote(precursorRT_and_mzMapDensity), ".png"),
    path = "plots",
    plot = precursorRT_and_mzMapDensity,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat(paste0("\n\n5) Graph ", quote(precursorRT_and_mzMapDensity), ".png were created.\n"))

  # return(precursorRT_and_mzMapDensity)
}

GraphPrecursorRT_mzMapDensity()
```

# 6) Graph: Peptides | Proteins ----
```{r}
# Counting the number of unique peptides and proteins per run
GraphNumberOfPeptidesAndProteins <- function() {
  diannReport <- DiannReport()

  diannReportByRun <- diannReport %>%
    dplyr::group_by(Run, condition) %>%
    dplyr::summarise(
      n_peptides = n_distinct(Stripped.Sequence),
      n_proteins = n_distinct(Protein.Ids))

  totalUniquePeptides <- n_distinct(diannReport$Stripped.Sequence)
  totalUniqueProteins <- n_distinct(diannReport$Protein.Ids)

  # Create the peptides graph
  peptidesPlot <- diannReportByRun %>%
    ggplot(aes(y = Run, x = n_peptides, fill = condition)) +
    geom_bar(stat = "identity", position = "dodge", show.legend = FALSE) +
    scale_fill_manual(values = params$colors) +
    geom_text(
      aes(
        label = n_peptides,
        hjust = ifelse(n_peptides > params$nMaxPeptides, 1.1, -0.15)
      ),
      color = "black", size = 7, nudge_x = -0.5, fontface = "bold"
    ) +
    labs(y = NULL, x = "Number of peptides", fill = NULL) +
    theme(
      text = element_text(size = 25),
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )

  # Create the proteins graph
  proteinsPlot <- diannReportByRun %>%
    ggplot(aes(y = Run, x = n_proteins, fill = condition)) +
    geom_bar(stat = "identity", position = "dodge", show.legend = FALSE) +
    scale_fill_manual(values = params$colors) +
    geom_text(
      aes(
        label = n_proteins,
        hjust = ifelse(n_proteins > params$nMaxProteins, 1.1, -0.15)
      ),
      color = "black", size = 7, nudge_x = -0.5, fontface = "bold"
    ) +
    labs(y = NULL, x = "Number of proteins", fill = NULL) +
    theme(
      text = element_text(size = 25),
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank()
    )


  # Concatenate peptides plot and proteins plot
  number_of_peptides_and_proteins <- (peptidesPlot | proteinsPlot) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  # Save file
  ggsave(
    filename = paste0("6- ", quote(number_of_peptides_and_proteins), ".png"),
    path = "plots",
    plot = number_of_peptides_and_proteins,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat(paste0("\n6) Graph 6-", quote(number_of_peptides_and_proteins), ".png were created.\n",
    "Total number of unique  peptides: ", totalUniquePeptides,
    "\nTotal number of unique proteins: ", totalUniqueProteins, "\n")
  )

  # return(peptidesPlot)
}

GraphNumberOfPeptidesAndProteins()
```

# 7) Graph: Sparsity Matrix ----
```{r}

# Sparsity matrix of unique proteins
GraphSparsityMatrix <- function() {
  diannReport <- DiannReport()

  uniqueGenes <-  FilterByDiannMatrix(diannReport)
  sparsityPlotRaw <- SparsityPlot(uniqueGenes)

  # Create a sparsity plot with unique genes FILTERED
  uniqueGenesFiltered <- diannReport %>%
    FilterByScore() %>%
    FilterBySample() %>%
    FilterByDiannMatrix()

  sparsityPlotFiltered <- SparsityPlot(uniqueGenesFiltered)


  # Create a sparsity plot with unique genes REDUCED and FILTERED
  uniqueGenesCleaned <- CleanDiannReport()
  sparsityPlotCleaned <- SparsityPlot(uniqueGenesCleaned)


  sparsity_matrix <- (sparsityPlotRaw | sparsityPlotFiltered | sparsityPlotCleaned) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  ggsave(
    filename = paste0("7-", quote(sparsity_matrix), ".png"),
    path = "plots",
    plot = sparsity_matrix,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat(paste0("\n\n7) Graph 7-", quote(sparsity_matrix), ".png were created.\n"))

}

GraphSparsityMatrix()
```

# 8) Graph: QuanUMS Evaluation ----
```{r}
#Shows the QuantUMS filter applied and how many peptides were removed
GraphQuantUMS <- function() {

  diannReport <- DiannReport()

  lowScoresPeptide <- diannReport %>%
    dplyr::filter(PG.MaxLFQ.Quality < params$pgScore &
      Empirical.Quality < params$eqScore) %>% 
    dplyr::group_by(Run) %>%
    dplyr::summarise(
      n = n_distinct(Stripped.Sequence))

  quantUMS <- diannReport %>%
    ggplot(aes(x = PG.MaxLFQ.Quality,
      y = Empirical.Quality)) +

    geom_pointdensity(size = 0.5) +

    geom_vline(xintercept = 0.75, linetype = "dashed", color = "black") +
    geom_hline(yintercept = 0.75, linetype = "dashed", color = "black") +
    viridis::scale_color_viridis(option = "plasma") +

    geom_text(data = lowScoresPeptide,
      aes(x = 0.25, y = 0.35, label = n),
      hjust = -0.1, vjust = 0.5,
      size = 9, fontface = "bold",
      color = "red", show.legend = FALSE) +

    labs(title = "QuantUMS scores for feature selection",
      x = "pgQ Score",
      y = "eQ Score",
      color = NULL) +

    facet_wrap(~Run, ncol = 6) +
    theme(plot.title = element_text(size = 30,
      face = "bold", hjust = 0.5),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 20),
    text = element_text(size = 20),
    axis.title = element_text(size = 30),
    axis.text.x = element_text(color = "black",
      angle = 90, vjust = 0.5, hjust = 1),
    legend.position = "none",
    panel.border = element_rect(color = "black", fill = NA),
    panel.background = element_rect(fill = "white")
    )

  ggsave(
    filename = paste0("8-", quote(quantUMS), ".png"),
    path = "plots",
    plot = quantUMS,
    width = 24, height = 20,
    units = "in", dpi = 300
  )

  cat(paste0("\n8) Graph 8-", quote(quantUMS), ".png were created.\n"))
}

GraphQuantUMS()
```

# 9) Create Imputation Matrix ----
```{r}
# Impute values to NA places using MICE package
CreateImputationMatrix_MICE <- function() {
  
  filenameImputation <- paste0("imputedMatrix_", params$imputMethod, ".rds")
  filenameResult <- paste0("result_", filenameImputation)
  
  filesExists <- (file.exists(filenameImputation) | file.exists(filenameResult))
  
  if (!(params$imputOverride) & filesExists) {
    
    cat("\nLoad file:", filenameResult,"\n")
    invisible(read_rds(filenameResult))
    
  } else {
    
    uniqueGenesCleaned <- CleanDiannReport()
    
    matrixForImputation <- log2(uniqueGenesCleaned + 1) %>%
      as.data.frame() %>%
      rownames_to_column(var = "protein")
    
    cat("\nCreating the imputed matrix.\n\nThis is going to take a while.\n")
    set.seed(params$setSeed)
    imputedMatrix <- mice::mice(matrixForImputation,
                                method = params$imputMethod,
                                m = params$imputM,
                                maxit = params$imputMaxit,
                                seed = params$imputSeed)
    
    result <- mice::complete(imputedMatrix)
    
    cat("\n\nCreate files:\n", filenameImputation, "\n", filenameResult)
    write_rds(imputedMatrix, file = filenameImputation)
    write_rds(result, file = filenameResult)
    
    invisible(result)
  }
}


# Two-Step Approach
# Step 1: Handles proteins that are completely missing in entire groups by imputing values slightly below the detection limit with added noise
# Step 2: Handles remaining missing values using either:
# Mean imputation for low-abundance proteins (simpler, more stable)
# MICE (Multiple Imputation) for high-abundance proteins (more sophisticated, preserves relationships)
# This approach recognizes that low-abundance proteins often have more technical noise, so simpler imputation is appropriate, while high-abundance proteins benefit from more sophisticated methods that preserve biological relationships.
CreateImputationMatrix_StepWise <- function() {
  
  fileName <- "result_imputation_stepWise.rds"
  fileExist <- file.exists(fileName)
  
  if (!(params$imputOverride) & fileExist) {
    
    cat("\nLoad file:", fileName,"\n")
    invisible(read_rds(fileName))
  } else {
    
    uniqueGenes <- DiannReport() %>%
      FilterByScore() %>%
      FilterByDiannMatrix()
    
    matrixForImputation <- log2(uniqueGenes + 1)
    groupLabels <- str_remove(colnames(matrixForImputation), params$regexString)
    
    imputedData <- StepWiseImputation(
      protein_matrix = matrixForImputation,
      group_vector = groupLabels,
      shift_value = -1.5,
      noise_type = "normal",
      noise_sd = 0.1,
      min_detection_method = "global",
      verbose = TRUE
    )
    result <- imputedData$imputed_data
    # log <- imputedData$missing_protein_log
    
    write_rds(result, fileName)
    invisible(result)
  }
}

cat("\n9) Imputation matrix were loaded.")
```

# 10) Graph: Cosine Similarity ----
```{r}

#Compares graphically the difference between samples using cosine similarity
GraphCosSimilarity <- function() {

  imputedMatrix <- CreateImputationMatrix_StepWise()
  cosineSimilarity <- imputedMatrix %>%
    lsa::cosine() %>%
    as.data.frame() %>%
    rownames_to_column(var = "Sample") %>%
    pivot_longer(-Sample, names_to = "Match") %>% # não entendi essa desgraça

    dplyr::mutate(Similarity = "Cosine similarity",
      Sample = factor(Sample, levels = unname(params$labels)),
      Match = factor(Match, levels = unname(params$labels))) %>%

    ggplot() +
    geom_tile(aes(x = Sample, y = Match, fill = value)) +
    viridis::scale_fill_viridis(option = "E") +
    labs(title = "Similarity matrix",
      x = NULL,
      y = NULL,
      fill = "Cosine similarity") +
    # theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
      text = element_text(size = 20),
      axis.text.x = element_text(angle = 90,
        hjust = 1, vjust = 0.5, color = "black"),
      axis.text.y = element_text(angle = 0,
        hjust = 1, vjust = 0.5, color = "black"),
      legend.position = "bottom",
      legend.title.position = "top",
      legend.title = element_text(hjust = 0.5),
      legend.key.width = unit(2.5, "cm"),
      legend.key.height = unit(0.3, "cm"),
      panel.border = element_rect(color = "black", fill = NA),
      panel.background = element_blank())

  ggsave(
    filename = paste0("10-", quote(cosineSimilarity), ".png"),
    path = "plots",
    plot = cosineSimilarity,
    width = 24, height = 20,
    units = "in", dpi = 300)

  cat(paste0("\n10) Graph 10-", quote(cosineSimilarity), ".png were created.\n"))
}

GraphCosSimilarity()
```

# 11) Graph: Principal Component Analysis (PCA) by K-means 
```{r}
#Show the optimal number of cluster by PCA and K-means
GraphPCA_Kmeans <- function() {
  imputedMatrix <- CreateImputationMatrix_StepWise()
  
  pcaComplete <- imputedMatrix %>%
    t() %>%
    prcomp(scale = TRUE)

  pcaTwoDimensions <- as.data.frame(pcaComplete$x[, 1:2])

  kmeans_clusters_p <- fviz_nbclust(pcaTwoDimensions,
    FUNcluster = kmeans,
    method = "wss") +

    geom_point(size = 4, color = "steelblue") +
    geom_vline(xintercept = params$numberOfClusters, linetype = "dashed") +
    theme_minimal() +
    labs(title = "Optimal number of clusters") +
    theme(plot.title = element_text(hjust = 0.5),
      text = element_text(color = "black", size = 20),
      title = element_text(color = "black", size = 20, face = "bold", hjust = 0.5),
      axis.text = element_text(color = "black"),
      axis.title = element_text(color = "black", face = "bold"),
      axis.ticks = element_line(color = "black"),
      panel.border = element_rect(color = "black", fill = NA))
  
  set.seed(params$setSeed)
  kMeansPCA <- kmeans(pcaTwoDimensions, centers = params$numberOfClusters)

  pcaPlot <- fviz_pca_ind(pcaComplete,
    geom = c("point", "text"),
    habillage = kMeansPCA$cluster,
    labelsize = 7, pointsize = 3,
    palette = params$colors,
    addEllipses = FALSE,
    ggtheme = theme_classic(),
    repel = TRUE) +

    labs(title = "PCA clustered by k-means") +
    theme_minimal() +

    theme(plot.title = element_text(hjust = 0.5),
      text = element_text(color = "black", size = 20),
      title = element_text(color = "black", size = 20,
        face = "bold", hjust = 0.5),
      axis.text = element_text(color = "black"),
      axis.title = element_text(color = "black", face = "bold"),
      strip.background = element_rect(fill = "grey90"),
      strip.text = element_text(face = "bold"),
      legend.title = element_text(face = "bold", hjust = 0.5),
      legend.title.position = "top",
      legend.position = "none",
      panel.border = element_rect(color = "black", fill = NA))


  kMeans_PCA <- (kmeans_clusters_p | pcaPlot) +
    plot_annotation(tag_levels = "A") &
    theme(plot.tag = element_text(size = 30, face = "bold"))

  ggsave(
    filename = paste0("11-", quote(kMeans_PCA), ".png"),
    path = "plots",
    plot = kMeans_PCA,
    width = 24, height = 10,
    units = "in", dpi = 300
  )

  cat("\n\n11) Graph ", quote(pcaPlot_and_kMeansPCA), ".png were created.\n")

}

GraphPCA_Kmeans()
```

# 12) Graph: Coefficient of Variation ----
```{r}
# Coefficient of Variation Graph
GraphCoefficientOfVariation <- function() {

  imputationResult <- CreateImputationMatrix_StepWise()

  conditions <- unique(DiannReport()$condition)
  CVs <- data.frame()

  cat("\nCalculating Coefficient of Variation...")

  for (condition in conditions) {
    CVs <- bind_rows(CVs, CV_Matrix(imputationResult, condition = condition))
  }

  CVs %>%
    dplyr::mutate(condition = factor(
      condition, levels = unique(str_remove(unname(params$labels), params$regexString))
    ))


  CVplot <- CVs %>%
    ggplot(aes(y = condition, x = cv, fill = condition)) +
    geom_violin(linewidth = 0.2) +
    geom_boxplot(width = 0.2, fill = "white",
      linewidth = 0.2, outlier.alpha = 0.5) +
    geom_vline(xintercept = 20, linetype = "dashed", color = "black") +
    scale_fill_manual(values = params$colors) +
    labs(
      y = NULL,
      x = "Coefficient of variation (%)",
      fill = NULL) +
    theme_linedraw() +
    theme(
      legend.position = "none",
      axis.title = element_text(size = 20, face = "bold"),
      axis.text = element_text(color = "black", size = 20, face = "bold"),
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
      axis.ticks = element_line(),
      line = element_blank(),
      strip.background = element_blank(),
      strip.text = element_text(size = 20, face = "bold", color = "black"))

  ggsave(
    filename = paste0("12-", quote(CVplot), ".png"),
    path = "plots",
    plot = CVplot,
    width = 12, height = 10,
    units = "in", dpi = 300)

  cat(paste0("\n\n12) Graph 12-", quote(CVplot), ".png were created.\n"))
}

GraphCoefficientOfVariation()
```

# 13) Load Limma Contrast Functions ----
```{r}

CreateContrastFitQuantUMS <- function() {
  
    limmaMTX <- CreateImputationMatrix_StepWise() %>% 
  normalizeBetweenArrays(method = "scale")
  
  #Resultado identico ao do Alison
  designGroups <- colnames(limmaMTX) %>% 
    str_remove_all(params$regexString) %>% 
    str_replace_all(" ", "_") %>% 
    str_replace_all("_&", "") %>% 
    factor(levels = unique(.))

  dg <- model.matrix(~ 0 + designGroups)
  colnames(dg) <- colnames(dg) %>% str_replace("designGroups", "")

  contrastMatrix <- do.call(
  limma::makeContrasts,
  c(params$samplesToCompare, list(levels = dg))) 
  
  fitQuantums <- lmFit(limmaMTX, dg, method = "robust")
  
  contrastFitQuantUMS <- limma::contrasts.fit(fitQuantums, contrastMatrix) %>% 
    limma::eBayes()
  
  cat("\n\nLimma Contrast Fit QuantUMS done\n")
  invisible(contrastFitQuantUMS)
}

ApplyLimmaTopTable <- function(contrastFitQuantUMS, sampleToCompare) {
  

  limmaResult <- limma::topTable(contrastFitQuantUMS,
                                  coef = sampleToCompare,
                                  number = Inf,
                                  adjust.method = "BH") %>% 
     rownames_to_column("proteins") %>% 
     dplyr::mutate(
       status = case_when(
         logFC > 0.58 & adj.P.Val <= 0.05 ~ "Increased",
         logFC < -0.58 & adj.P.Val <= 0.05 ~ "Decreased",
         TRUE ~ "Not significant"),
       status = factor(status, 
                       levels = c("Decreased", "Not significant", "Increased")),
       condition = str_replace_all(sampleToCompare, "_", " ")
     )
  
  invisible(limmaResult)
}

CompareLimmaResults <- function() {

  contrastFitQuantUMS <- CreateContrastFitQuantUMS()
  diannReport <- DiannReport()
  
  resultQuantUMS <- list() # Result from samples comparison
  # significantHiLo <- list() # Top/Bottom 10 protein significant altered
  
 for (item in names(params$samplesToCompare)) {
   limmaResult <- ApplyLimmaTopTable(contrastFitQuantUMS, item)
   
  resultQuantUMS <- resultQuantUMS %>% bind_rows(limmaResult)

 }
  # significant <- limmaResult %>% 
  #   dplyr::filter(status != "Not significant") 
  # 
  # significantHiLo <- significantHiLo %>% dplyr::bind_rows(
  #     dplyr::slice_max(significant, n = 10, order_by = logFC),
  #     dplyr::slice_min(significant, n = 10, order_by = logFC)
  #   )
  
  result <- resultQuantUMS %>% 
    dplyr::mutate(logFC = round(logFC, 2),
                  AveExpr = round(AveExpr, 2),
                  B = round(B, 2)) %>% 
    dplyr::rename(Protein = proteins,
                  Comparison = condition)
  
  
  cat("\n\nComparisons between groups done.\n")
  write_tsv(result, "allLimmaResultsCombined.tsv")
  # View(significantHiLo)
  invisible(result)
}

#TODO: Later, would be nice to plot the significantHiLo
signicantProteinsHiLo <- function() { 
  #Do the right things! 
  }

cat("\n\n13) Load Limma Contrast Functions")
```

# 14) Graph: Bland-Altman ----
```{r}
#Create the graph of Bland-Altman
GraphBlandAltman <- function() {
  
  allLimmaResults <- CompareLimmaResults()
  
  # count the number of proteins in each status
  signif_proteins <- allLimmaResults %>%
    dplyr::filter(status != "Not significant") %>%
    group_by(status, Comparison) %>%
    dplyr::summarise(proteins = n())
  
  allLimmaResults %>%
    dplyr::filter(status != "Not significant") %>%
    write_tsv("significant_proteins.tsv")
  
  blandAltmanLimmaPlot <- ggplot(allLimmaResults,
                                 aes(x = AveExpr,
                                     y = logFC,
                                     color = status)
  ) +
    geom_point(alpha = 0.3) +
    geom_smooth(method = "gam", se = FALSE, color = "darkblue", linewidth = 1) +
    guides(color = guide_legend(override.aes = list(size = 5, alpha = 1)),
           shape = guide_legend(override.aes = list(size = 5, alpha = 1))) +
    geom_hline(yintercept = c(-0.58, 0.58), linetype = "dashed", color = "black") +
    scale_color_manual(values = c("Decreased" = "steelblue",
                                  "Not significant" = "grey60",
                                  "Increased" = "firebrick")) +
    facet_wrap(~Comparison, scales = "free", ncol = 5) +
    geom_text(data = signif_proteins %>% 
                dplyr::filter(status == "Decreased"),
              aes(x = 13.5, y = -3, label = paste0(proteins)),
              size = 8, fontface = "bold",
              hjust = 0.5,
              vjust = -1, 
              show.legend = FALSE) +
    geom_text(data = signif_proteins %>% 
                dplyr::filter(status == "Increased"),
              aes(x = 13.5, y = 1, label = paste0(proteins)),
              size = 8, fontface = "bold",
              hjust = 0.5,
              vjust = -1, 
              show.legend = FALSE) +
    geom_label_repel(data = allLimmaResults %>% 
                       dplyr::filter(status != "Not significant" & Protein %in% params$genesToHighlight_blandAltman),
                     aes(label = paste0(Protein)),
                     show.legend = FALSE) +
    labs(title = "Bland-Altman plots of limma analysis",
         x = "log<sub>2</sub>(Average protein abundance)",
         y = "log<sub>2</sub>FC") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"),
          text = element_text(size = 20),
          legend.position = "bottom",
          legend.title = element_blank(),
          legend.box = "vertical",
          strip.text = element_text(size = 15, face = "bold", color = "black"),
          axis.text = element_text(color = "black"),
          axis.title = element_markdown(size = 20, face = "bold"),
          axis.ticks = element_line(color = "black"),
          panel.border = element_rect(color = "black", 
                                      fill = NA)
    )
  
  ggsave(paste0("14-", quote(blandAltmanLimmaPlot), ".png"),
         path = "plots",
         plot = blandAltmanLimmaPlot,
         width = 25, height = 12,
         units = "in", dpi = 300,
         bg = "white")
  
  cat(paste0("\n\n14) Graph 14-", quote(blandAltmanLimmaPlot), ".png were created.\n"))
}

GraphBlandAltman()
```

# 15) Graph:Boxplot of Log2FC
```{r}
#Create the Box Plot by Log2FC
GraphBoxPlotLog2FC <- function() {
  
  allLimmaResults <- CompareLimmaResults()
  
  log2FC_BoxPlot <- allLimmaResults %>%
    ggplot(aes(y = Comparison,
               x = logFC,
               fill = Comparison)) +
    geom_boxplot(outlier.alpha = 0.4, linewidth = 0.25, fill = "#476F84FF") +
    geom_vline(xintercept = c(0), linetype = "dashed", color = "red") +
    labs(y = NULL,
         x = "log<sub>2</sub>FC") +
    theme_minimal() +
    theme(text = element_text(size = 20),
          legend.position = "none",
          strip.text = element_text(size = 20, face = "bold", color = "black"),
          axis.text = element_text(color = "black"),
          axis.title = element_markdown(size = 20, face = "bold"),
          axis.ticks = element_line(color = "black"),
          panel.border = element_rect(color = "black", fill=NA)
    )
  
  ggsave(
    filename = paste0("15-", quote(log2FC_BoxPlot), ".png"),
    path = "plots",
    plot = log2FC_BoxPlot, 
    width = 12, height = 12,
    units = "in" ,dpi = 300,
    bg = "white"
  )
  
  cat(paste0("\n\n15) Graph 15-", quote(log2FC_BoxPlot), ".png were created.\n"))
}

GraphBoxPlotLog2FC()
```

# 16) Graph: Distribution of proteins of interest ----
```{r}
#Abundance comparison of different proteins in different groups
GraphProteinsComparison <- function() {
  
  imputedMatrix <- CreateImputationMatrix_StepWise() %>%
    as.data.frame() %>% 
    rownames_to_column("protein")
  
  proteinsComparisonPlot <- imputedMatrix %>%
    dplyr::filter(protein %in% params$genesToHighlight_proteinsComparison) %>%
    
    pivot_longer(cols = -c(protein),
                 names_to = "sample",
                 values_to = "abundance") %>%
    
    dplyr::mutate(condition = str_remove(sample, params$regexString),
                  condition = factor(condition, levels = unique(condition))) %>%
    ggplot(aes(x = condition, y = abundance, fill = condition)) +
    geom_boxplot(outlier.alpha = 0.4, linewidth = 0.25) +
    geom_jitter(aes(color = condition), alpha = 0.7, size = 0.5) +
    labs(x = NULL,
         y = "log<sub>2</sub>(Abundance)") +
    facet_wrap(~protein, ncol = 5, scales = "free_y") +
    scale_fill_manual(values = params$colors) +
    theme_minimal() +
    theme(text = element_text(size = 20),
          legend.position = "none",
          strip.text = element_text(size = 20, face = "bold", color = "black"),
          axis.text = element_text(color = "black"),
          axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
          axis.title = element_markdown(size = 20, face = "bold"),
          axis.ticks = element_line(color = "black"),
          panel.border = element_rect(color = "black", fill=NA)
    )
  
  ggsave(
    filename = paste0("16-", quote(proteinsComparisonPlot), ".png"),
    path = "plots",
    plot = proteinsComparisonPlot, 
    width = 25, height = 30,
    units = "in" ,dpi = 300,
    bg = "white"
  )
  
  cat(paste0("\n\n16) Graph 16-", quote(proteinsComparisonPlot), ".png were created.\n"))
}

GraphProteinsComparison()
```

